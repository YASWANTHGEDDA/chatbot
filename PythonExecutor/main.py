from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import logging
import io
import contextlib
import sys
import subprocess
import tempfile
import os

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Python Code Execution Service",
    description="A sandboxed service for executing Python code generated by the LLM.",
    version="0.1.0",
)

class CodeExecutionRequest(BaseModel):
    code: str
    timeout: int = 10 # seconds

class CodeExecutionResponse(BaseModel):
    output: str
    error: str | None = None

@app.post("/execute_code", response_model=CodeExecutionResponse)
async def execute_code(request: CodeExecutionRequest):
    """Executes the provided Python code in a sandboxed environment using isolate."""
    code = request.code
    temp_dir = None
    output = ""
    error_output = ""
    execution_error = None

    try:
        # Create a temporary directory for isolate to use as a sandbox
        temp_dir = tempfile.mkdtemp(prefix="isolate_sandbox_")
        box_id = os.path.basename(temp_dir) # Use the temp dir name as box_id for isolate

        # Initialize the sandbox with isolate
        # We use --init and --cleanup to ensure a clean slate and automatic removal
        init_command = ["isolate", "--box-id", box_id, "--init"]
        logger.info(f"Initializing isolate sandbox: {' '.join(init_command)}")
        init_result = subprocess.run(init_command, capture_output=True, text=True, check=False)
        if init_result.returncode != 0:
            raise RuntimeError(f"Isolate init failed: {init_result.stderr}")

        # Write the user's code to a temporary file inside the sandbox's work directory
        # The isolate box directory is typically /var/local/lib/isolate/<box_id>/box
        # We need to write to a path accessible from the host first, then it will be copied or symlinked by isolate
        # For simplicity, we'll write to a temp file outside, and then copy it into the isolate box.
        # A more robust solution might involve writing directly to the box's /tmp or using a specific isolate feature.

        code_file_path = os.path.join(temp_dir, "user_code.py")
        with open(code_file_path, "w") as f:
            f.write(code)
        
        # Command to run the Python code inside the isolate sandbox
        # --time and --mem limit resources. --full-path allows access to Python executable.
        # --stdin, --stdout, --stderr redirect output to files within the sandbox.
        # /usr/bin/python3 is assumed to be available in the python:3.9-slim-buster base image
        run_command = [
            "isolate", "--box-id", box_id, 
            "--run", 
            "--time=", str(request.timeout), 
            "--mem=102400", # 100MB memory limit
            "--wall-time=", str(request.timeout + 2), # A bit more wall time than CPU time
            "--fsize=1024", # 1MB file size limit for created files
            "--processes=1", # Limit to one process
            "--cg-mem", # Use cgroups for memory limiting
            "--cg-timing", # Use cgroups for time accounting
            "--share-net", # Allow network access (can be restricted if needed)
            "--dir=/etc", # Allow read-only access to /etc
            "--dir=/usr", # Allow read-only access to /usr
            "--dir=/lib", # Allow read-only access to /lib
            "--dir=/bin", # Allow read-only access to /bin
            "--dir=/sbin", # Allow read-only access to /sbin
            "--dir=/tmp", # Allow write access to /tmp
            "--no-clean-box", # Keep box for inspection after execution
            "--meta=/tmp/meta.txt", # Write metadata to this file
            "--stdin=/dev/null", # No stdin for security
            "--stdout=/tmp/stdout.txt", # Redirect stdout to a file in sandbox
            "--stderr=/tmp/stderr.txt", # Redirect stderr to a file in sandbox
            "--env=PYTHONIOENCODING=utf-8", # Ensure utf-8 encoding for python output
            "--env=PYTHONUNBUFFERED=1", # Unbuffered output
            "--user=nobody", # Run as unprivileged user
            "--group=nogroup", # Run as unprivileged group
            "--chroot", # Enable chroot
            "--box-id", box_id, # Specify box ID again for run command
            "--", # Separator for command to execute
            "python3", "user_code.py" # Command and arguments to execute inside the box
        ]

        logger.info(f"Running code in isolate sandbox: {' '.join(run_command)}")
        run_result = subprocess.run(run_command, capture_output=True, text=True, check=False)

        # Read output and error from the files inside the sandbox
        # Isolate's `run` command will place outputs in the sandbox's `/tmp` directory
        # We need to read these files from the host's perspective, using isolate's `cat` command
        stdout_cat_command = ["isolate", "--box-id", box_id, "--cat-file", "/tmp/stdout.txt"]
        stderr_cat_command = ["isolate", "--box-id", box_id, "--cat-file", "/tmp/stderr.txt"]

        output_result = subprocess.run(stdout_cat_command, capture_output=True, text=True, check=False)
        error_result = subprocess.run(stderr_cat_command, capture_output=True, text=True, check=False)

        output = output_result.stdout
        error_output = error_result.stdout

        # Check isolate's exit status
        if run_result.returncode != 0:
            execution_error = f"Isolate execution failed with exit code {run_result.returncode}. Isolate stderr: {run_result.stderr}"
            # Attempt to read metadata for more details (e.g., timeout, memory limit exceeded)
            meta_cat_command = ["isolate", "--box-id", box_id, "--cat-file", "/tmp/meta.txt"]
            meta_result = subprocess.run(meta_cat_command, capture_output=True, text=True, check=False)
            if meta_result.returncode == 0:
                execution_error += f"\nIsolate metadata: {meta_result.stdout}"

    except Exception as e:
        execution_error = str(e)
        logger.error(f"Unhandled exception during code execution setup: {execution_error}")
    finally:
        # Clean up the sandbox. This is crucial for security and resource management.
        if temp_dir and os.path.exists(temp_dir):
            cleanup_command = ["isolate", "--box-id", box_id, "--cleanup"]
            logger.info(f"Cleaning up isolate sandbox: {' '.join(cleanup_command)}")
            cleanup_result = subprocess.run(cleanup_command, capture_output=True, text=True, check=False)
            if cleanup_result.returncode != 0:
                logger.error(f"Isolate cleanup failed: {cleanup_result.stderr}")
            
            # Even if isolate cleanup fails, try to remove the temp dir if it still exists
            try:
                if os.path.exists(temp_dir): # Check again after isolate cleanup
                    import shutil
                    shutil.rmtree(temp_dir)
                    logger.info(f"Force removed temporary directory {temp_dir}")
            except Exception as e:
                logger.error(f"Error force removing temporary directory {temp_dir}: {e}")

    if execution_error or error_output:
        final_error = execution_error if execution_error else error_output
        logger.warning(f"Code execution finished with errors. Output: {output}, Errors: {final_error}")
        return CodeExecutionResponse(output=output, error=final_error)
    
    logger.info(f"Code executed successfully. Output: {output}")
    return CodeExecutionResponse(output=output)

@app.get("/health")
async def health_check():
    return {"status": "ok", "service": "Python Code Execution Service"} 